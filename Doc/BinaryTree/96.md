## 不同的二叉搜索树

**题目来源**：[LeetCode-96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

### 题目描述

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数

### 示例

**示例 1**

![image](https://github.com/Rain-Life/algorithm-go/blob/master/photos/BinaryTree/96/96-1.png)

```go
输入：n = 3
输出：5
```

**示例 2**

```go
输入：n = 1
输出：1
```

**提示：**

- `1 <= n <= 19`

## 解题

### 解法一：动态规划

**思路**

根据题目可知，给定一个整数n，求由值为1~n的节点，可以构建出多少颗BST。我们知道BST的中序遍历刚好是有序的。给定的值为 1~n 的节点恰巧有序，等于是BST的中序遍历结果

因此，我们只需要遍历1~n的每一个数字i，并将i作为根节点，那么1~(i-1)就是i的左子树上的结点，(i-1)~n就是i的右子树上的结点。因为BST根的值不同，所以是可以保证每棵BST是唯一的

这样，其实就将一个大的问题，分解成了多个小的子问题（1~(i-1)和(i-1)~n可以用相同的方式继续分解），并且子问题可以复用，所以就想到用动态规划

题目要求计算BST的个数，可以定义如下两个函数：

- G(n)：长度为n的序列，能构成多少不同的BST
- F(i, n)：以i为根、序列长度为n的不同BST个数

G(n)就是我们本题要得到的。从上边的两个函数的定义，不难看出来它们的关系是：

```go
G(n) = f(1, n) + f(2, n) + f(3, n)+...f(n, n)
```

意思就是**长度为n的序列能构成的不同的BST数量就等于序列中每一个值作为根节点能构成的不同的BST个数的和**

这样我们其实就很容易想到递归了。递归的终止条件就是当序列长度是1或0的时候，此时只有一种情况

```go
G(1) = 1
G(0) = 0
```

当i为根的时候，不难知道，这n个序列能构成的不同的BST个数，是左子树能构成的不同的BST个数和右子树能构成的不同的BST个数的乘积，即：

```go
F(1, n) = G(i-1)*G(n-i)
```

比如假设有[1,2,3,4,5]这么一个序列，以3位根，那左子树序列就是[1,2]，又子树序列就是[4,5]。我用上边定义的F函数表示就是F(3, 5)

那左子树序列[1,2]用G函数表示就是G(2)，右子树序列[4,5]用G函数表示就是G(2)。你会发现G函数是和序列的内容无关的，只与序列长度有关。因此不难得到

```go
F(3, 5) = G(2) * G(2)
```

有了以上结论和公式，就不难实现了

**代码**

```go
func numTrees(n int) int {
    G := make([]int, n + 1)
	G[0], G[1] = 1, 1
	for i := 2; i <= n; i++ {
		for j := 1; j <= i; j++ {
			G[i] += G[j-1] * G[i-j]
		}
	}
	return G[n]
}
```