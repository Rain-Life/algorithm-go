## 上下翻转二叉树

**题目来源**：[LeetCode-156.上下翻转二叉树](https://blog.csdn.net/xiaobailaji/article/details/118762339)

### 题目描述

给定一个[二叉树](https://so.csdn.net/so/search?from=pc_blog_highlight&q=%E4%BA%8C%E5%8F%89%E6%A0%91) ，其中所有的右节点要么是具有兄弟节点（拥有相同父节点的左节点）的叶节点，要么为空，将此二叉树上下翻转并将它变成一棵树， 原来的右节点将转换成左叶节点。返回新的根

```go
输入: [1,2,3,4,5]

    1
   / \
  2   3
 / \
4   5

输出: 返回二叉树的根 [4,5,2,#,#,3,1]

   4
  / \
 5   2
    / \
   3   1  
说明:

对 [4,5,2,#,#,3,1] 感到困惑? 下面详细介绍请查看 二叉树是如何被序列化的。

二叉树的序列化遵循层次遍历规则，当没有节点存在时，'#' 表示路径终止符
```

### 示例

```go
这里有一个例子:

   1
  / \
 2   3
    /
   4
    \
     5
上面的二叉树则被序列化为 [1,2,3,#,#,4,#,#,5].
```

## 解题

### 解法一：递归

**思路**

对于这道题，需要观察二叉树翻转前和翻转后的变化，通过题目中的示例，可以发现翻转前和翻转后有以下特点

1. 翻转前的最左子节点（4），变成了翻转后的根节点（4）
2. 翻转前的最左子节点的兄弟结点（5），变成了翻转后的根节点（4）的左子节点（5）
3. 翻转前的最左子节点的父节点（2），变成了翻转后的根节点（4）的右子节点（2）
4. 你发现翻转前的二叉树的每一个左子节点，都具有上边的三步的特点。比如翻转前的（2）这个节点，它的兄弟结点3，翻转后，变成了它的左子节点，它的父节点，翻转后，变成了它的右子节点

发现了以上翻转前和翻转后的规律，我们就不难发现，就是不断的找到原二叉树的左子节点，然后按照前三步进行翻转。一个大的问题，转化成了多个相同的小问题，不难想到用递归实现（需要注意的是，在翻转的过程中需要记录待翻转的左子节点的兄弟节点和父节点）

另外需要注意的是，如果根节点不存在或者二叉树没有左节点，那这颗二叉树是不用翻转的，直接返回根节点即可

翻转过程中是用的深度优先搜索(DFS)的思想，因为我们发现翻转前的最左子节点是翻转后的根节点，所以我们需要从最左子节点开始翻转

![image](https://github.com/Rain-Life/algorithm-go/blob/master/photos/BinaryTree/156/156-1.png)

**代码**

```go
// binary tree upside down
func upsideDownBinaryTree(root *TreeNode) *TreeNode {
	if root == nil || root.Left == nil {
		return root
	}
	//翻转前，拿到待反转的左子节点的兄弟节点
	leftNode, rightNode := root.Left, root.Right
	newRoot := upsideDownBinaryTree(leftNode) //对左子节点进行翻转
	leftNode.Left = rightNode
	leftNode.Right = root
	root.Left = nil //因为翻转后，原来的父节点的左右子节点要被替换了，所以这里在当前的左右子节点被处理后，将其置空
	root.Right = nil

	return newRoot
}
```